<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="HandheldFriendly" content="true">
  <script type="text/javascript" src="js/svg.min.js" charset="utf-8"></script>
  <style type="text/css">
  .main {
    text-align: center;
    padding: 20;
  }

  #testEl {
    color: red;
    font-family: 'astro';
    background-color: #eee;
  }

  .red {
    color: red;
  }

  @font-face {
    font-family: 'astro';
    src: url('font/astro.woff') format('woff');
    /* Legacy iOS */
    font-weight: normal;
    font-style: normal;
  }

  .starFont {
    font-family: 'astro'
  }
  </style>
</head>

<body>
  <div id="testEl">asdfasdf</div>
  <div id="testSVG"></div>
  <div id="main" class="main">
    <div id="astro"></div>
  </div>
  <script>
  var planetsData = {
    'sun': {
      'name': 'sun',
      'lon': 316.81797600093626,
      'lat': 0.0004108106661321218,
      'spd': 1.0098260642621426,
      'r': 0
    },
    'moon': {
      'name': 'moon',
      'lon': 326.0242175662381,
      'lat': -1.2666176621572691,
      'spd': 11.784215357124594,
      'r': 0
    },
    'mercury': {
      'name': 'mercury',
      'lon': 334.2201905101414,
      'lat': 1.3454868374151474,
      'spd': 0.48104779438062906,
      'r': 0
    },
    'venus': {
      'name': 'venus',
      'lon': 301.8172830238122,
      'lat': -0.633749811484642,
      'spd': 1.2511515060964484,
      'r': 0
    },
    'mars': {
      'name': 'mars',
      'lon': 329.01665019172503,
      'lat': -1.0414450814576528,
      'spd': 0.7880249228264802,
      'r': 0
    },
    'jupiter': {
      'name': 'jupiter',
      'lon': 190.16361397054163,
      'lat': 1.4654571685733873,
      'spd': -0.03487566175408574,
      'r': 0
    },
    'saturn': {
      'name': 'saturn',
      'lon': 189.4960389523151,
      'lat': 2.5208657429238936,
      'spd': -0.029923668733999875,
      'r': 0
    },
    'uranus': {
      'name': 'uranus',
      'lon': 239.77387282404084,
      'lat': 0.22525176978027348,
      'spd': 0.024867982375553765,
      'r': 0
    },
    'neptune': {
      'name': 'neptune',
      'lon': 264.1927105872144,
      'lat': 1.3089504736466098,
      'spd': 0.02563382736298081,
      'r': 0
    },
    'pluto': {
      'name': 'pluto',
      'lon': 204.31516118590744,
      'lat': 17.343013961732847,
      'spd': -0.005452316997889284,
      'r': 0
    },
    'mean_node': {
      'name': 'mean_node',
      'lon': 130.62312516773838,
      'lat': 0,
      'spd': -0.05296177377545064,
      'r': 0
    }
    // 'chiron': {
    //   'name': 'chiron',
    //   'lon': 43.5052345101053,
    //   'lat': -2.11740419283264,
    //   'spd': 0.013930854869670384,
    //   'r': 0
    // },
    // 'pholus': {
    //   'name': 'pholus',
    //   'lon': 359.2381717864676,
    //   'lat': -21.31818577049128,
    //   'spd': 0.056111419439730525,
    //   'r': 0
    // },
    // 'ceres': {
    //   'name': 'ceres',
    //   'lon': 105.24143734697998,
    //   'lat': 9.622921376999386,
    //   'spd': -0.1523610105635953,
    //   'r': 0
    // },
    // 'pallas': {
    //   'name': 'pallas',
    //   'lon': 28.182609745094318,
    //   'lat': -30.62175266741695,
    //   'spd': 0.37003767719312464,
    //   'r': 0
    // },
    // 'juno': {
    //   'name': 'juno',
    //   'lon': 216.89360101511954,
    //   'lat': 6.977622611331037,
    //   'spd': 0.10345614541051873,
    //   'r': 0
    // },
    // 'vesta': {
    //   'name': 'vesta',
    //   'lon': 157.20224800433607,
    //   'lat': 8.371002154803717,
    //   'spd': -0.20587487782108838,
    //   'r': 0
    // },
    // 'cupido': {
    //   'name': 'cupido',
    //   'lon': 218.1866086023104,
    //   'lat': 1.077466224606196,
    //   'spd': 0.0007074584118527127,
    //   'r': 0
    // },
    // 'chariklo': {
    //   'name': 'chariklo',
    //   'lon': 34.98530189104559,
    //   'lat': 22.96795814372611,
    //   'spd': 0.024017344628646242,
    //   'r': 0
    // },
    // 'chaos': {
    //   'name': 'chaos',
    //   'lon': 32.45982525521509,
    //   'lat': -3.3494148329201727,
    //   'spd': 0.00839405903008128,
    //   'r': 0
    // },
    // 'eris': {
    //   'name': 'eris',
    //   'lon': 14.207630934323765,
    //   'lat': -18.973085727365532,
    //   'spd': 0.005986353714959591,
    //   'r': 0
    // },
    // 'nessus': {
    //   'name': 'nessus',
    //   'lon': 110.99714757927057,
    //   'lat': 16.279877634271934,
    //   'spd': -0.041067750800038993,
    //   'r': 0
    // }
  };

  var planets = [
    'sun',
    'moon',
    'mercury',
    'venus',
    'mars',
    'jupiter',
    'saturn',
    'uranus',
    'neptune',
    'pluto',
    'mean_node',
    'asc',
    'mc'
    // 'chiron',<text id="xp_p_4" x="474.358489044309" y="458.445971680622" class="xp_symbol xp_symbol_ruled Mars">Q</text>
    // 'pholus',
    // 'ceres',
    // 'pallas',
    // 'juno',
    // 'vesta',
    // 'cupido',
    // 'chariklo',
    // 'chaos',
    // 'eris',
    // 'nessus'
  ];

  var houseArr = [352.0564146335398,
    35.04129140503142,
    63.44271090260005,
    85.69597507922174,
    107.25433306655145,
    133.180868936381,
    172.05641463353982,
    215.04129140503142,
    243.44271090260006,
    265.69597507922174,
    287.25433306655145,
    313.180868936381
  ];
  var asc = houseArr[0];
  var mc = houseArr[9];
  // astroShow(draw,planetsData, houseArr, asc, mc);
  houseArr = [225.38677571201202,
    254.9245449275749,
    288.9354258928624,
    324.74309363455245,
    357.1118108559691,
    23.675867760700157,
    45.386775712012025,
    74.92454492757491,
    108.93542589286238,
    144.74309363455245,
    177.11181085596914,
    203.67586776070019
  ];
  asc = houseArr[0];
  mc = houseArr[9];
  planetsData['asc'] = {
    'name': 'asc',
    'lon': asc
  };
  planetsData['mc'] = {
    'name': 'mc',
    'lon': mc
  };


  var pointRotate = function(centerX, centerY, orgX, orgY, rotateAngle) {
    var x = orgX - centerX;
    var y = orgY - centerY;
    var l = (rotateAngle * Math.PI) / 180;
    var x1 = Math.cos(l) * x - Math.sin(l) * y;
    var y1 = Math.cos(l) * y + Math.sin(l) * x;
    return [x1 + centerX, y1 + centerY];
  };

  // var pointRotateZeroCenter = function(orgX, orgY, rotateAngle) {
  //   var l = (rotateAngle * Math.PI) / 180;
  //   var x1 = Math.cos(l) * orgX - Math.sin(l) * orgY;
  //   var y1 = Math.cos(l) * orgY + Math.sin(l) * orgX;
  //   return [x1, y1];
  // };

  /**
   * 将点对象集合分散到一个圆上,根据dot.data(dotCircleName).lon进行角度旋转
   * @param  {string} dotCircleName 点名称,用于获取dot中的data
   * @param  {int} centerX    圆中心坐标X
   * @param  {int} centerY    圆中心坐标Y
   * @param  {array} dotArr     dot对象数组
   * @param  {int} radius     圆半径
   * @param  {int} ascAngle   asc线即水平线的角度,用于修正整个圆到水平
   * @return {array}            dot array
   */
  var dotCircleCreate = function(dotCircleName, centerX, centerY, dotArr, radius, ascAngle) {
    // var groupDots = draw.group();
    var dotCircleArr = [];
    var fixAngle = ascAngle || 0;
    // rotate dots
    for (var i = 0; i < dotArr.length; i++) {
      var dotOne = dotArr[i];
      var pData = dotOne.data(dotCircleName);
      var newPosi = pointRotate(centerX, centerY, centerX - radius, centerY, 0 - pData.lon + fixAngle);
      dotOne.center(newPosi[0], newPosi[1]);
      dotCircleArr.push(dotOne);
    }
    return dotCircleArr;
  };

  var dotArrCreate = function(dotCircleName, dotOne, dotNameArr, dotData) {
    var dotArr = [];
    dotOne.data(dotCircleName, dotData[dotNameArr[0]]);
    dotArr.push(dotOne);

    for (var i = 1; i < dotNameArr.length; i++) {
      dotArr.push(dotOne.clone().data(dotCircleName, dotData[dotNameArr[i]]));
    }
    return dotArr;
  };

  var planetsCircle = function(draw, centerX, centerY, planets, planetsData, radius, ascAngle) {


    // var circle = draw.circle(radius * 2).fill('#ccc').stroke({
    //   width: 1,
    //   color: '#000'
    // }).center(centerX, centerY);
    // groupPlanets.add(circle);

    // create planet dots
    var dotRadius = 2;
    var dot = draw.circle(dotRadius * 2).fill('#e4e');
    var dotArr = dotArrCreate('planet', dot, planets, planetsData);
    // rotate dots
    var dotPlanetsArr = dotCircleCreate('planet', centerX, centerY, dotArr, radius, ascAngle);

    //center cross
    // var crossLen = 10;
    // var line1 = draw.line(0, 0, crossLen, 0).stroke({
    //   width: 0.5
    // }).center(centerX, centerY);
    // var line2 = draw.line(0, 0, 0, crossLen).stroke({
    //   width: 0.5
    // }).center(centerX, centerY);
    return dotPlanetsArr;
  };

  /**
   * txt circle
   * @param  {svg} draw
   * @param  {string} dotCircleName circleName
   * @param  {int} centerX       centerX
   * @param  {float} centerY       centerY
   * @param  {array} txts          ['a','b',...] or [['a',21],['b',16.5],['txt',(angle)]...]
   * @param  {object} fontStyle     font style
   * @param  {float} radius        radius
   * @param  {float} ascAngle      adjust angle
   * @return {array}               txt svg objects array
   */
  var txtCircle = function(draw, dotCircleName, centerX, centerY, txts, fontStyle, radius, ascAngle) {
    var textObjs = [];
    var splitAngle = 360 / txts.length;
    for (var i = 0; i < txts.length; i++) {
      var txtItem = txts[i];
      var aTxt = txtItem;
      var cAngle = splitAngle * i;
      if (txtItem.constructor.name === 'Array') {
        aTxt = txtItem[0];
        cAngle = txtItem[1];
      }
      var txtOne = draw.text(aTxt).font(fontStyle).fill(fontStyle.color).data(dotCircleName, {
        'lon': cAngle
      });
      textObjs.push(txtOne);
    }
    var txtPlanetArr = dotCircleCreate(dotCircleName, centerX, centerY, textObjs, radius, ascAngle);
    return txtPlanetArr;
  };

  var distFromBBox = function(bbox1, bbox2) {
    var dx = bbox2.cx - bbox1.cx;
    var dy = bbox2.cy - bbox1.cy;
    var dist = Math.sqrt(dx * dx + dy * dy);
    return dist;
  };

  var hitTest = function(obj1, obj2) {
    var hitPadding = 4;
    var bbox1 = obj1.bbox();
    var bbox2 = obj2.bbox();
    var dist = distFromBBox(bbox1, bbox2);
    // console.log(dx+','+dy+',dist:'+dist+',width:'+bbox1.width+','+bbox2.width);

    //注意这里简单化使用width,准确的作法是使用bbox的直径,这里通过padding进行了容错
    return dist < (bbox1.width + bbox2.width + hitPadding) / 2;
  };

  var adjustCircleHitObj = function(obj1, obj2, centerX, centerY) {
    if (!hitTest(obj1, obj2)) {
      return false;
    }
    var changeAngle = 4;
    var bbox1 = obj1.bbox();
    var bbox2 = obj2.bbox();
    // var hitPadding = 6;
    // var goodDist = (bbox1.width + bbox2.width + hitPadding) / 2;
    //因为obj1和obj2是排过序的,所以,obj2需要顺时针方向调整,obj1逆时针调整

    // console.log(bbox1.x + ',' + bbox2.x + ',' + changeAngle);
    var newPo1 = pointRotate(centerX, centerY, bbox1.cx, bbox1.cy, 0 - changeAngle);
    obj1.center(newPo1[0], newPo1[1]);
    var newPo2 = pointRotate(centerX, centerY, bbox2.cx, bbox2.cy, changeAngle);
    obj2.center(newPo2[0], newPo2[1]);
    return true;
  };


  var aspectCount = function(planetsData) {

    var result = []; //[[aspectType,orb,applying]]
    var sortFn = function(a, b) {
      return a.angle - b.angle;
    };
    var isRetrograde = function(p) {
      return p.speed < 0;
    };
    var samePair = {};

    for (var aName in planetsData) {
      var p1 = planetsData[aName];
      for (var bName in planetsData) {
        var p2 = planetsData[bName];
        if (p1.name === p2.name) {
          continue;
        }
        if (samePair[p1.name + '#' + p2.name]) {
          //already done.
          continue;
        }
        samePair[p2.name + '#' + p1.name] = true;
        var aspectTypes = [{
            name: 'conjunct',
            major: true,
            angle: 0,
            orb: 8,
            symbol: '<'
          }, {
            name: 'semisextile',
            major: false,
            angle: 30,
            orb: 2,
            symbol: 'y'
          },
          // { name: 'decile', major: false, angle: 36, orb: 1.5, symbol: '>' },
          //// {name:'novile', major: false, angle: 40, orb: 1.9, symbol: 'M' },
          {
            name: 'semisquare',
            major: false,
            angle: 45,
            orb: 2,
            symbol: '='
          },
          //// {name:'septile', major: false, angle: 51.417, orb: 2, symbol: 'V' },
          {
            name: 'sextile',
            major: true,
            angle: 60,
            orb: 5,
            symbol: 'x'
          },
          // { name: 'quintile', major: false, angle: 72, orb: 2, symbol: 'Y' },
          //// {name:'bilin', major: false, angle: 75, orb: 0.9, symbol: '-' },
          //// {name:'binovile', major: false, angle: 80, orb: 2, symbol: ';' },
          {
            name: 'square',
            major: true,
            angle: 90,
            orb: 6,
            symbol: 'c'
          },
          //// {name:'biseptile', major: false, angle: 102.851, orb: 2, symbol: 'N' },
          //// {name:'tredecile', major: false, angle: 108, orb: 2, symbol: 'X' },
          {
            name: 'trine',
            major: true,
            angle: 120,
            orb: 7,
            symbol: 'Q'
          },
          // { name: 'sesquare', major: false, angle: 135, orb: 2, symbol: 'b' },
          // { name: 'biquintile', major: false, angle: 144, orb: 2, symbol: 'C' },
          // { name: 'inconjunct', major: false, angle: 150, orb: 2, symbol: 'n' },
          //// {name:'treseptile', major: false, angle: 154.284, orb: 1.1, symbol: 'B' },
          //// {name:'tetranovile', major: false, angle: 160, orb: 3, symbol: ':' },
          //// {name:'tao', major: false, angle: 165, orb: 1.5, symbol: '—' },
          {
            name: 'opposition',
            major: true,
            angle: 180,
            orb: 7,
            symbol: 'm'
          }
        ];
        var l1 = p1.lon,
          l2 = p2.lon,
          r1 = isRetrograde(p1),
          r2 = isRetrograde(p2),
          s1 = Math.abs(p1.spd),
          s2 = Math.abs(p2.spd);
        var ct = false;
        var distAngle = Math.abs(p1.lon - p2.lon);
        if (distAngle > 180 + aspectTypes[aspectTypes.length - 1].orb) {
          distAngle = l1 > l2 ? (360 - l1 + l2) : (360 - l2 + l1);
          ct = true;
        }
        //applying or separating
        var applying = 0;
        if (p2.spd && p1.spd) {
          if ((distAngle < 0 && !ct && l2 > l1 || distAngle > 0 && !ct && l1 > l2 || distAngle < 0 && ct && l1 > l2 || distAngle > 0 && ct && l2 > l1) && (!r1 && !r2 && s2 > s1 || r1 && r2 && s1 > s2 || r1 && !r2) || (distAngle > 0 && !ct && l2 > l1 || distAngle < 0 && !ct && l1 > l2 || distAngle > 0 && ct && l1 > l2 || distAngle < 0 && ct && l2 > l1) && (!r1 && !r2 && s1 > s2 || r1 && r2 && s2 > s1 || !r1 && r2)) {
            applying = 1;
          } else {
            applying = -1;
          }
        }

        var compareObj = {
          'name': 'target',
          'angle': distAngle
        };
        aspectTypes.push(compareObj);
        aspectTypes.sort(sortFn);
        // console.log(aspectTypes);
        for (var i = 0; i < aspectTypes.length; i++) {
          var cur = aspectTypes[i];
          if (cur.name === 'target') {
            var pre = aspectTypes[i - 1];
            var next = aspectTypes[i + 1];
            if (pre.angle + pre.orb > cur.angle) {
              //match pre
              result.push([pre.name, p1.name, p2.name, cur.angle - pre.angle, applying]);
              break;
            }
            if (next.angle - next.orb < cur.angle) {
              //match next
              result.push([next.name, p1.name, p2.name, next.angle - cur.angle, applying]);
              break;
            }
            // console.log('--- not match:%j',[p1.name,p2.name]);
            break;
          }
        }
      }
    }
    console.log('aspect result:------->', result.length);
    // console.log(result);
    return result;
  };

  function test() {
    var draw = SVG('testSVG').size('100%', '100%').viewbox(0, 0, 500, 500);



    var dot = draw.circle(4).fill('blue').center(100, 100);
    // var centerPoint = draw.use(dot).move(100, 100);
    // var p1 = draw.use(dot).move(200, 100);

    // var ro = 0 - planetsData.sun.lon;
    // var g1 = draw.group();
    // var newPo = pointRotate(100, 100, 200, 100, ro);
    // var p2 = draw.use(dot).move(newPo[0], newPo[1]);
    var line = draw.line(0, 0, 200, 0).stroke('#000').center(100, 100);
    for (var i = 0; i < 12; i++) {
      line.clone().rotate(30 * i);
    }
    // var lineAsc = draw.line(0, 100, 200, 100).stroke('red');
    // line.rotate(ro);
    // lineAsc.rotate(0 - houseArr[0]);
    // g1.add(lineAsc).add(line).add(p2);
    // g1.rotate(houseArr[0] - 180);
    // var dot2 = draw.circle(10).fill('blue').move(20, 20);
    // dot2.attr('fill', 'red');
    var txtEclipticCircle = function(draw, centerX, centerY, radius, ascAngle) {
      var txtEclipticGroup = draw.group();
      var txtEclipticText = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L'];
      var txtObjArr = [];
      var dotCircleName = 'txtEcliptic';
      for (var i = 0; i < txtEclipticText.length; i++) {
        var txtOne = draw.text(txtEclipticText[i]).font({
          'size': 20,
          'font-family': 'astro'
        }).fill('red').data(dotCircleName, {
          'lon': 30 * i + 10
        });
        txtObjArr.push(txtOne);
        txtEclipticGroup.add(txtOne);
      }
      var txtCircleArr = dotCircleCreate(dotCircleName, centerX, centerY, txtObjArr, radius, ascAngle);
      return txtEclipticGroup;
    };
    txtEclipticCircle(draw, 250, 250, 100, 0);

  }


  test();



  function astroShow(draw, showPlanets, planetsData, houseArr, asc, mc) {
    draw.clear();
    var maxSize = 500;
    var circleDiameter = 480;
    var centerX = circleDiameter / 2;
    var centerY = circleDiameter / 2;
    var padding = 10;
    var EclipticWidth = 80;
    draw.size('100%', '100%').viewbox(0, 0, maxSize, maxSize);
    // var bgColor = new SVG.Color('rgb(250, 253, 185 )');
    var bgColor = new SVG.Color('rgb(248,194,136)');
    var strokeColor = new SVG.Color('rgb(145,84,40)');
    var strokeColorBlue = new SVG.Color('rgb(34,108,162)');
    // var bgColorBlue = new SVG.Color('rgb(234,255,255)');
    var bgColorBlue = new SVG.Color('rgb(250,253,185)');
    var strokeWidth1 = 0.5;
    var strokeWidth2 = 1;
    var strokeStyleOuter = {
      width: 1.5,
      color: strokeColor
    };
    var strokeStyleInner = {
      width: strokeWidth1,
      color: strokeColorBlue
    };
    var strokeStyleInner2 = {
      width: strokeWidth2,
      color: strokeColorBlue
    };

    var groupAll = draw.group();

    var drawEcliptic = function() {

      var groupEcliptic = draw.group();
      //Ecliptic circles
      var circle1 = draw.circle(circleDiameter).fill(bgColor).stroke(strokeStyleOuter).center(centerX, centerY);
      var circle2 = draw.circle(circleDiameter - EclipticWidth).fill(bgColorBlue).center(centerX, centerY).stroke(strokeStyleOuter);


      //Ecliptic lines
      var lineEcliptic = draw.defs().line(0, 0, 0, circleDiameter).stroke(strokeStyleOuter).center(centerX, centerY);
      var lineEclipticGroup = draw.group();
      for (var i = 0; i < 12; i++) {
        var lineEclipticOne = draw.use(lineEcliptic).rotate(i * 30);
        lineEclipticGroup.add(lineEclipticOne);
      }



      //Ecliptic groupEcliptic
      groupEcliptic.add(circle1).add(lineEclipticGroup).add(circle2);
      return groupEcliptic;
    };

    var drawHouse = function() {
      var groupHouse = draw.group();
      //house
      var circle3 = draw.circle(circleDiameter - 120).fill('#FFF').center(centerX, centerY).stroke(strokeStyleInner2);
      var circle4 = circle3.clone().size(circleDiameter - 200).center(centerX, centerY);
      //House lines
      var lineHouse = draw.defs().line(0, 0, circleDiameter - EclipticWidth, 0).stroke(strokeStyleInner2).center(centerX, centerY);
      var lineHouseGroup = draw.group();

      for (var j = 0; j < houseArr.length; j++) {
        var lineHouseOne = draw.use(lineHouse).rotate(0 - houseArr[j]);
        lineHouseGroup.add(lineHouseOne);
      }
      var circleCenter = lineHouseGroup.clone().maskWith(circle3.clone().fill('#222').attr({
        stroke: null
      }));
      groupHouse.add(lineHouseGroup).add(circle3).add(circle4).add(circleCenter); //.add(lineStarGroup);

      return groupHouse;
    };

    // Ecliptic text circle
    var txtEclipticCircle = function(draw, centerX, centerY, radius, ascAngle) {
      var txtEclipticText = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L'];
      var fontStyle = {
        'size': 20,
        'font-family': 'astro',
        'color': 'red'
      };
      var fontStyle2 = {
        'size': 15,
        'font-family': 'astro',
        'color': 'green'
      };
      var txtEclipticRulerArr = ['Q', 'P', 'O', 'N', 'M', 'O', 'P', 'V', 'R', 'S', 'T', 'U'];
      var txtEcliptics = txtCircle(draw, 'txtEcliptic', centerX, centerY, txtEclipticText, fontStyle, radius, ascAngle);
      var txtEclipticRulers = txtCircle(draw, 'txtEclipticRuler', centerX, centerY, txtEclipticRulerArr, fontStyle2, radius, ascAngle + 6);
      var txtEclipticGroup = draw.group();
      for (var i = 0; i < txtEcliptics.length; i++) {
        txtEclipticGroup.add(txtEcliptics[i]).add(txtEclipticRulers[i]);
      }
      return txtEclipticGroup;
    };

    // House text circle
    var txtHouseCircle = function(draw, centerX, centerY, radius, ascAngle) {
      var txts = [];
      var txtHouseRulerArr = ['Q', 'P', 'O', 'N', 'M', 'O', 'P', 'V', 'R', 'S', 'T', 'U'];
      var txtRulers = [];
      for (var i = 0; i < houseArr.length; i++) {
        var nextItem = houseArr[i + 1];
        if (i + 1 === houseArr.length) {
          nextItem = houseArr[0];
        }
        var centerAngle = (nextItem - houseArr[i]) / 2;
        if (centerAngle < 0) {
          centerAngle += 180;
        }
        var angle = houseArr[i] + centerAngle;
        // console.log('angle:'+angle);
        txts.push([(i + 1) + '', angle]);
        txtRulers.push([txtHouseRulerArr[i], angle - 6]);
      }
      var fontStyle = {
        'size': 15,
        'font-family': 'astro',
        'color': 'blue'
      };
      var fontStyle2 = {
        'size': 15,
        'font-family': 'astro',
        'color': 'green'
      };
      var txtHouses = txtCircle(draw, 'txtHouse', centerX, centerY, txts, fontStyle, radius, ascAngle);
      var txtHouseRulers = txtCircle(draw, 'txtHouseRuler', centerX, centerY, txtRulers, fontStyle2, radius, ascAngle);
      var txtHouseGroup = draw.group();
      for (var j = 0; j < txtHouses.length; j++) {
        txtHouseGroup.add(txtHouses[j]).add(txtHouseRulers[j]);
      }
      return txtHouseGroup;
    };

    var planetDotMap = {};
    var drawDotPlanets = function(centerX, centerY) {
      var groupPlanets = draw.group();
      // planets dots circle
      var pDotArr = planetsCircle(draw, centerX, centerY, showPlanets, planetsData, centerX - 100, asc);
      // planets txts circle //draw, dotCircleName, centerX, centerY, txts, fontStyle, radius, ascAngle
      var fontStyle = {
        'size': 20,
        'font-family': 'astro',
        'color': 'red'
      };
      var txts1 = ['M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'f', 'g'];
      var txts = [];
      for (var i = 0; i < planets.length; i++) {
        txts.push([txts1[i], planetsData[showPlanets[i]].lon]);
      }
      // txts.push(['f', asc]); //add ASC dot
      var pTxtArr = txtCircle(draw, 'txtPlanet', centerX, centerY, txts, fontStyle, centerX - 80, asc);
      // 按circle角度排序
      var sortFn = function(dataName, obj1, obj2) {
        var anglePT1 = obj1.data(dataName).lon;
        var anglePT2 = obj2.data(dataName).lon;
        return anglePT1 - anglePT2;
      };
      var sortFn1 = function(obj1, obj2) {
        return sortFn('txtPlanet', obj1, obj2);
      };
      var sortFn2 = function(obj1, obj2) {
        return sortFn('planet', obj1, obj2);
      };


      for (var m = 0; m < pDotArr.length; m++) {
        planetDotMap[showPlanets[m]] = pDotArr[m];
      }
      // planetDotMap['asc'] = pDotArr[pDotArr.length - 1];

      pTxtArr.sort(sortFn1);
      pDotArr.sort(sortFn2);
      // 动态调整文字角度,直到相互间的距离足够大,次数不超过50次
      for (var j = 0; j < 50; j++) {
        var adjuested = false;
        for (var i = 1; i < pTxtArr.length; i++) {
          var adjustRe = adjustCircleHitObj(pTxtArr[i], pTxtArr[i - 1], centerX, centerY);
          if (adjustRe) {
            adjuested = true;
            // console.log(pTxtArr[i].data('txtPlanet').lon);
          }
        }
        if (!adjuested) {
          console.log('adjustTimes:' + j);
          break;
        }
      }
      // 连接点与图
      var linkerArr = [];
      for (var i = 0; i < pDotArr.length; i++) {
        var bbox1 = pDotArr[i].bbox();
        var bbox2 = pTxtArr[i].bbox();
        var cx1 = bbox1.cx;
        var cy1 = bbox1.cy;
        var cx2 = bbox2.cx;
        var cy2 = bbox2.cy;
        linkerArr.push(draw.line(cx1, cy1, cx2, cy2).stroke('#ccc'));
      }
      for (var k = 0; k < pDotArr.length; k++) {
        groupPlanets.add(linkerArr[k]).add(pDotArr[k]).add(pTxtArr[k]);
      }
      return groupPlanets;
    };

    var aspectCreate = function(planetDotMap) {
      var aspectArr = aspectCount(planetsData);
      var aspectGroup = draw.group();
      var lineStyleArr = [
        strokeStyleOuter, strokeStyleInner, strokeStyleInner2
      ];
      for (var i = 0; i < aspectArr.length; i++) {
        var aptArr = aspectArr[i];
        var dot1 = planetDotMap[aptArr[1]];
        var dot2 = planetDotMap[aptArr[2]];
        var orb = aptArr[3];
        var lineSytle = lineStyleArr[0];
        if (orb > 1 && orb < 2) {
          lineSytle = lineStyleArr[1];
        } else if(orb >= 2) {
          lineSytle = lineStyleArr[2];
        }
        if (dot2 == undefined) {
          console.log('ERR! aptArr:' + aptArr[1] + ' ' + aptArr[2]);
          continue;
        }
        var aptLine = draw.line(dot1.cx(), dot1.cy(), dot2.cx(), dot2.cy()).stroke(lineSytle).back();
        aspectGroup.add(aptLine);
      }
      return aspectGroup;
    };


    var groupEcliptic = drawEcliptic().rotate(asc);
    var groupHouse = drawHouse().rotate(asc);
    var txtEcliptics = txtEclipticCircle(draw, centerX, centerY, centerX - 20, asc - 15);
    var txtHouseArr = txtHouseCircle(draw, centerX, centerY, centerX - 50, asc);
    var dotPlanets = drawDotPlanets(centerX, centerY);
    var aspectGroup = aspectCreate(planetDotMap);
    groupAll.add(groupEcliptic).add(groupHouse).add(txtEcliptics).add(txtHouseArr).add(aspectGroup).add(dotPlanets);


    // ASC and MC
    var lineAsc = draw.line(0 - padding * 2, 0, maxSize, 0).stroke(strokeStyleInner).center(centerX, centerY);
    var lineMc = draw.line(0 - padding * 2, 0, maxSize, 0).stroke(strokeStyleInner2).center(centerX, centerY);
    lineMc.rotate(0 - mc + asc);
    var ascFontStyle = {
      'size': 12,
      'color': 'blue'
    };
    var txtAsc = draw.text('Asc').font(ascFontStyle).fill(ascFontStyle.color).center(50, centerY);
    var txtMc = draw.text('Mc').font(ascFontStyle).fill(ascFontStyle.color);
    var txtMcPosi = pointRotate(centerX, centerY, 50, centerY, 0 - mc + asc);
    txtMc.center(txtMcPosi[0], txtMcPosi[1]);

    groupAll.add(lineAsc).add(lineMc).add(txtAsc).add(txtMc);
    groupAll.move(padding, padding);

  }

  function startAstro(target) {
    if (!SVG.supported) {
      alert('SVG not supported');
      return false;
    }
    var draw = SVG(target);


    astroShow(draw, planets, planetsData, houseArr, asc, mc);
  }
  startAstro('astro');
  </script>
</body>

</html>
